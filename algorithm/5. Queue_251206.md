## Queue란?
- 먼저 들어온 데이터가 먼저 나가는 선형구조 ➡ First In First Out(FIFO)
- Front: 저장된 원소 중 첫번째 원소이자 삭세된 위치
- Rear: 저장된 원소 중 마지막 원소

    ### 기본 연산
    - ```from collections import deque ```

    |연산|기능|
    |:---|:---|
    |```deque()```|공백 상태의 큐 생성|
    |```queue.append()```|**rear 다음**에 원소를 **삽입**|
    |```queue.popleft()```|front에서 원소를 **삭제**하고 **반환**|
    |```is_empty()```|공백 상태인지 확인|
    |```is_full()```|포화 상태 확인|
    |```qpeek()```|front에서 원소 반환(삭제❌)|
    🚨 is_full(): 배열 기반으로 큐를 생성할 때 필요한 내가 선언하는 함수, deque()의 경우 메모리 제한 도달 전에 자동으로 크기를 늘리므로 필요 없음

---

## 큐 종류
### 1. 선형 큐 (Linear Queue)
- 데이터를 일렬로 저장, 앞에서 꺼내고 뒤에서 넣는 기본 큐 구조

    |상태|의미|
    |:---|:---|
    |```front == rear == -1```|초기 상태|
    |```front == rear```|공백 상태|
    |```rear == n - 1```|포화상태|

    ```python
    # python
    from collections import deque

    queue = deque()

    for i in range(1, 4): # 세 개의 데이터 1,2,3을 차례로 삽입
        queue.append(i)
    
    for _ in range(3): # 큐에서 세 개의 데이터 차례로 출력
        print(queue.popleft())
    ```
    ```C++
    #include <iostream>
    #include <deque>

    using namespace std;

    int main ()
    {
        deque<int> queue;

        for (int i = 1; i < 4; i++)
        {
            queue.push_back(i);
        }

        for (int i = 0; i < 3; i++)
        {
            cout<< queue.front() << endl; // front 값 출력만
            queue.pop_front(); // 실제로 front 값 삭제
        }

        return 0;
    }
    ```

### 2. 원형 큐 (Circular Queue)
- 선형 큐의 문제점: 배열의 앞 부분에 활용할 수 있는 공간이 있음에도 포화상태로 인식
- 선형 큐의 공간 낭비를 막기 위해 처음과 끝이 연결된 구조

    |상태|의미|
    |:---|:---|
    |```front == rear == (n-1)```|front와 rear의 위치가 배열의 마지막 인덱스에 도착|
    |```front == (rear + 1) % n```|포화 상태|

    ```python
    # python
    # dequeue 없이 구현하기
    
    n = 4
    queue = [0] * n
    front = rear = 0

    # 값 추가하기
    for i in range(1, n + 1):
        if front == (rear + 1) % n: # 포화상태
            break

        else:
            rear += 1
            queue[rear % n] = i

    # 값 삭제하기
    for _ in range(n):
        if front == rear: # 공백상태
            break

        else:
            front += 1
            queue[front % n] =  0
    ```
    ```C++
    // C++
    #include <iostream>
    #include <vector>

    using namespace std;

    int main ()
    {
        vector<int> queue(4, 0);
        int front = 0
        int rear = 0

        for (int i = 1, i < 4; i++)
        {
            if (front == (rear + 1) % 4) break;

            else
            {
                queue.push_back(i % 4);
                rear += 1;   
            }
        }

        for (int i = 0; i < 4; i++)
        {
            if (rear == (front + 1) % 4) break;

            else
            {
                cout << queue[front] << endl;
                queue[front] = 0;
                front += 1
            }
        }
    }
    ```
### 3. 연결 큐 (Linked Queue)
- 연결 리스트를 이용해 구현한 큐, 크기를 필요한 만큼 늘리고 줄이는게 가능
### 4. 우선순위 큐 (Priority Queue)
### 참고
- C++