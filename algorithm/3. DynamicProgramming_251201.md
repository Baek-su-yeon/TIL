## 재귀 호출
- 함수가 자신과 같은 작업을 반족해야 할 때, 자신을 다시 호출하는 구조
- 반복적으로 자기 자신을 호출하거나 전체를 부분 문제로 나눌 수 있는 경우에 프로그램의 크기를 줄이고 간단하게 작성할 수 있는 방법

    ```python
    # python
    # 기본형
    def recursive(i, n): # i = 현재 단계, n = 목표 단계
        if i == n: # 종료 조건
            return
        else: # 재귀 함수 호출
            recursive(i + 1, n)
    
    # 응용 1. 모든 배열 원소에 접근하는 재귀함수
    def recursive(i, arr):
        if i == len(arr):
            return
        else:
            # 제일 마지막 원소부터 출력될 것
            print(arr[i])
            recursive(i + 1, arr)
    
    # 응용 2. 배열 원소 검색
    def recursive(i, target, arr):
        if arr[i] == target:
            return print(arr[i])
        elif i == len(arr):
            return print("No data")
        else:
            recursive(i + 1, target, arr)
    ```
    ```C++
    // C++
    #include <iostream>
    #include <vector>

    using namespace std;

    // 기본형
    void recursive(int i, int n)
    {
        if (i == n) return;
        else recursive(i + 1, n);
    }

    // 응용 1. 모든 배열 원소에 접근하는 재귀함수
    void recursive(int i, vector<int> arr)
    {
        if (i == arr.size()) return;
        else
        {
            cout << arr[i] << endl;
            recursive(i + 1, arr)
        }
    }

    // 응용 2. 배열 원소 검색
    void recursive(int i, int target, vector<int> arr)
    {
        if (i == arr.size()) return;
        else if (i == target) return cout << arr[i] << endl;
        else recursive(i + 1, target, arr)
    }
    ```

---
## 메모이제이션 기법
- **핵심 조건**
1. 동일한 계산의 반복: 함수가 동일한 입력 값으로 여러 번 호출될 때
2. 참조 투명성: 함수의 출력이 **오직 입력 값**에만 의존, 외부 상태(시간,전역 변수 등)에 의해 변하지 않을 때

    ### 과정
    1. 함수가 호출되면, 먼저 입력 값(인수)를 기반으로 **저장소(캐시)**에 결과가 있는지 확인
    2. 캐시 히트(결과가 있을 경우): 저장된 결과 즉시 반환(계산 생략, O(1))
    3. 캐시 미스(결과가 없을 경우): 함수를 실행하여 결과 계산
    4. 결과를 반환하기 전에 해당 입력 값과 결과 값 캐시에 저장
    ```python
    # python
    # 피보나치 수열(메모이제이션 ❌)
    def fibo(n):
        # 1. 종료조건
        if n <= 1:
            return n # 0, 1은 값이 그대로 나옴

        else:
            return fibo(n - 2) + fibo(n - 1)
    # fibo(5)
    # fibo(3) + fibo(4)
    # fibo(1) + fibo(2) + fibo(2) + fibo(3)
    # 1 + fibo(0) + fibo(1) + fibo(0) + fibo(1) + fibo(1) + fibo(2)
    # 1 + 0 + 1 + 0 + 1 + 1 + fibo(1) + fibo(0)
    # 1 + 0 + 1 + 0 + 1 + 1 + 1 + 0
    # 5

    # 피보나치 수열(메모이제이션 ⭕)
    memo = [0] * (n + 1)
    memo[0] = 0
    memo[1] = 1
    
    def fibo(n):
        if memo[n] != 0: 
            return memo[n]
        memo[n] = fibo(n - 1) + fibo(n - 2)
        return memo[n]
    # fibo(5)
    # memo[5] = fibo(4) + fibo(3)
    # memo[5] = fibo(3) + fibo(2) + fibo(2) + fibo(1) -> fibo(2)까지 바로 계산되고 그럼 바로 3, 4 가능
    ```
    ```C++
    // C++
    #include <iostream>
    #include <vector>

    using namespace std;

    // 피보나치 수열 (메모이제이션 ❌)
    int fibo(int n)
    {
        if (n < 2)
            return n;
        
        return fibo(n - 1) + fibo(n - 2);
    }

    // 피보나치 수열 (메모이제이션 ⭕)
    vector<int> memo(5, 0); // memo 배열을 5 크기로 0 초기화
    memo[0] = 0;
    memo[1] = 1;

    int fibo(vector<int>& memo, n)
    {
        if (memo[n] != 0)
            return memo[n];
        
        memo[n] = fibo(n - 1) + memo(n - 2);
        return memo[n];
    }
    ```
## 동적 계획법(Dynamic Programming)
- 복잡한 문제를 여러 개의 작은 부분 문제로 나눈 다음, 이 부분 문제들의 해답을 계산하고 저장(메모이제이션)하여 나중에 동일한 부분 문제가 발생했을 때 저장된 결과를 재활용함으로써 효율적으로 문제를 해결하는 알고리즘 설계 기법

**1. 적용 조건**
- **최적 부분 구조**: 큰 문제의 최적 해답이 작은 부분 문제의 최적 해답들로부터 얻어질 수 있어야함
- **중복되는 부분 문제**: 문제를 재귀적으로 나눌 때, 동일한 작은 부분 문제가 반복해서 나타나야함

**2. 해결 방법론**
|방법|설명|구현 방식|특징|
|:---|:---|:---|:---|
|하향식 (Top-Down)|큰 문제 ➡ 작은 문제로 재귀 호출, 결과 계산 시 메모이제이션을 통해 저장|재귀 + 메모이제이션|장점: 직관적, 코드 간결 / 단점: 재귀 호출 오버헤드|
|상향식 (Bottom-Up)|작은 문제 ➡ 큰 문제, 점진적으로 더 큰 문제의 해답을 계산하고 테이블에 저장|반복문 + DP 테이블|장점: 오버헤트 없음, 빠름|

---

## DP 테이블
동적 계획법에서 상향식 방식으로 문제를 해결할 때, 계산된 부분 문제들의 **해답을 저장하고 관리**하기 위해 사용되는 **배열 또는 표**

**1. 구조 및 명칭**
- 구조: 보통 1차원 또는 2차원 배열
- 저장 내용: 각 셀 또는 문제의 특정 상태에 대한 최적의 해답 저장

**2. 작동 방식(상향식)**
1. 테이블 초기화: 가장 작은 문제의 해답을 테이블의 초반 셀에 직접 채우기
2. 반복 계산: 반복문을 사용하여 작은 문제의 해답을 참고하여 점진적으로 더 큰 문제의 해답을 계산
3. 결과 저장: 계산된 해답을 해당 인덱스의 테이블 셀에 저장
4. 최종 반환: 테이블의 마지막 셀에 저장된 값이 최종 문제의 해답

**하향식 vs 상향식**
|특징|상향식(DP 테이블)|하향식(메모이제이션)|
|:---|:---|:---|
|구현방식|반복문(for loop)|재귀 호출|
|계산순서|작은문제부터 큰 문제로 **순차적** 계산|큰 문제에서 시작, **필요한 부분 문제만 계산**|
|저장소|DP 테이블|캐시 또는 딕셔너리|

```python
# python
# 상향식 피보나치 수열 함수
def fibo(n):
    dptable = [0] * (n + 1)
    dptable[0] = 0
    dptable[1] = 1

    for i in range(2, n + 1):
        dptable[i] = dptable[i - 2] + dptable[i - 1]

    return dptable[n]
```
```C++
// C++
#include <iostream>
#include <vector>

int fibo(int n)
{
    vector<int> dptable(n + 1, 0);
    dptable[0] = 0;
    dptable[1] = 1;

    for (int i = 2; i < n + 1; i++)
    {
        dptable[i] = dptable[i - 1] + dptable[i - 2];
    }

    return dptable[n];
}
```