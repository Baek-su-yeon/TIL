## 버블 정렬
- 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
- 시간복잡도: **O(n^2)**

    ### 과정
    1. 첫번째 원소부터 인접한 원소끼리 계속 교환하며 맨 마지막 자리까지 이동
    2. 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬
    ```python
    # python
    
    # 오름차순
    def bubble_sort(num_list, list_len):
        for i in range(list_len - 1, 0, -1):
            # 한 단계 끝나면 가장 큰 원소가 마지막 자리로 정렬
            # 즉 이 for문이 끝나면 제일 뒤에는 큰 원소가 있어서 볼 필요 없으니 거꾸로 반복
            for j in range(i):
                if num_list[j] > num_list[j + 1]:
                    num_list[j], num_list[j + 1] = num_list[j + 1], num_list[j]

    # 내림차순
    def bubble_sort_reverse(num_list, list_len):
        for i in range(list_len - 1, 0, -1):
            for j in range(i):
                if num_list[j] < num_list[j + 1]:
                    num_list[j], num_list[j + 1] = num_list[j + 1], num_list[j]
    ```
    ```C++
    #include <vector>
    #include <algorithm> // swap 함수를 사용하기 위해 포함

    void bubbleSort(std::vector<int>& arr) {
        int n = arr.size();
        for (int i = 0; i < n - 1; ++i) {
            for (int j = 0; j < n - 1 - i; ++j) {
                if (arr[j] > arr[j + 1]) {
                    std::swap(arr[j], arr[j + 1]);
                }
            }
        }
    }
    ```
---
## 카운팅 정렬
- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업
- 시간복잡도: O(n + k), n = 리스트 길이, k = 정수의 최댓값
- 제한 사항 1. 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
- 제한 사항 2. 카운트들을 위한 충분한 공간을 할당하려면 집합 내 가장 큰 정수를 알아야 가능

    ### 과정
    1. DATA에서 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열에 저장
    2. 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 카운트 원소 조정
    3. DATA의 마지막 원소부터 왼쪽으로 이동, 카운트[1]부터 n까지 이동 시 감소, TEMP에 원소 삽입
    ```python
    # python
    def counting_sort(data, temp, k):
        # data는 정렬할 배열, temp는 정렬 완료 후 배열
        count = [0] * (k + 1)

        # 1. DATA에서 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열에 저장
        for i in data:
            count[i] += 1

        # 2. 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 카운트 원소 조정
        for i in range(1, k + 1):
            count[i] += count[i-1]
        
        # 3. DATA의 마지막 원소부터 왼쪽으로 이동, 카운트[1]부터 n까지 이동 시 감소, TEMP에 원소 삽입
        # 반복되는 데이터는 마지막 위치부터 저장되게됨
        # 그래서 처음부터 돌게되면 앞에 나온게 뒤에 위치되어서 데이터 회손될 수 있으므로 거꾸로 도는 것
        for i in range(len(data) - 1, -1, -1):
            count[data[i]] -= 1
            temp[count[data[i]]] = data[i]
    ```
    ```C++
    // C++
    #include <vector>
    #incldue <iostream>

    using namespace std

    void counting_sort(vector<int>& data, vector<int> temp, int k)
    {
        vector<int> count(k + 1, 0);

        for (int i = 0; i < data.size; i++)
        {
            count[data[i]]++;
        }

        for (int i = 1, i < count.size; i++)
        {
            count[i] += count[i - 1];
        }

        for (int i = data.size - 1; i >= 0 ; i--)
        {
            int value = data[i]; // 이거 안하면 엉뚱한 데이터 들어감
            count[data[i]]--;
            temp[count[value]] = value;
        }
    }
    ```
---
## 2차원 배열
### 입력
```python
# python
"""
입력 예시 1.
3
1 2 3
4 5 6
7 8 9
"""
n = int(input())
arr = [list(map(int, input().split())) for _ in range(n)]

"""
입력 예시 2.
3
123
456
789
"""
n = int(input())
arr = [list(map(int, input())) for _ in range(n)]
```
```C++
// C++
#include <vector>
#include <iostream>

using namespace std;

int main()
{
    // n 입력 받기
    int n;
    cin >> n;

    // n x n 크기 2차원 벡터 선언
    vector<vector<int>> arr(n, vector<int>(n));

    // n 줄에 걸쳐 n개의 정수 입력
    for (int i = 0; i < n ; ++i)
    {
        for (int j = 0; j < n; ++j)
        {
            // cin은 공백(스페이스, 엔터)을 무시하고 다음 정수 찾음
            cin >> arr[i][j]
        }
    }

    int n;
    cin >> n;

    // N x N 크기의 2차원 벡터(배열) 선언
    std::vector<std::vector<int>> arr(n, std::vector<int>(n));
    std::string line;

    // cin으로 N을 읽고 나면, 바로 다음에 개행 문자(\n)가 남아있습니다.
    // getline을 사용하려면 이 개행 문자를 제거해야 합니다.
    std::getline(std::cin, line); 

    // N줄에 걸쳐 문자열로 입력받고 처리
    for (int i = 0; i < n; ++i)
    {
        // 한 줄 전체를 문자열로 읽습니다. (예: "456")
        std::getline(std::cin, line); 
        
        for (int j = 0; j < n; ++j)
        {
            // 문자열의 j번째 문자를 정수로 변환
            // C++에서 '0' ~ '9' 문자는 아스키 코드 순서대로 정렬되어 있습니다.
            // 따라서 문자 '4'에서 문자 '0'의 아스키 값을 빼면 정수 4가 됩니다.
            arr[i][j] = line[j] - '0';
        }
    }
}
```
