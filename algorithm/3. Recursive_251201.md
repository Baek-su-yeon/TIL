## 재귀 호출
- 함수가 자신과 같은 작업을 반족해야 할 때, 자신을 다시 호출하는 구조
- 반복적으로 자기 자신을 호출하거나 전체를 부분 문제로 나눌 수 있는 경우에 프로그램의 크기를 줄이고 간단하게 작성할 수 있는 방법

    ```python
    # python
    # 기본형
    def recursive(i, n): # i = 현재 단계, n = 목표 단계
        if i == n: # 종료 조건
            return
        else: # 재귀 함수 호출
            recursive(i + 1, n)
    
    # 응용 1. 모든 배열 원소에 접근하는 재귀함수
    def recursive(i, arr):
        if i == len(arr):
            return
        else:
            # 제일 마지막 원소부터 출력될 것
            print(arr[i])
            recursive(i + 1, arr)
    
    # 응용 2. 배열 원소 검색
    def recursive(i, target, arr):
        if arr[i] == target:
            return print(arr[i])
        elif i == len(arr):
            return print("No data")
        else:
            recursive(i + 1, target, arr)
    ```
    ```C++
    // C++
    #include <iostream>
    #include <vector>

    using namespace std;

    // 기본형
    void recursive(int i, int n)
    {
        if (i == n) return;
        else recursive(i + 1, n);
    }

    // 응용 1. 모든 배열 원소에 접근하는 재귀함수
    void recursive(int i, vector<int> arr)
    {
        if (i == arr.size()) return;
        else
        {
            cout << arr[i] << endl;
            recursive(i + 1, arr)
        }
    }

    // 응용 2. 배열 원소 검색
    void recursive(int i, int target, vector<int> arr)
    {
        if (i == arr.size()) return;
        else if (i == target) return cout << arr[i] << endl;
        else recursive(i + 1, target, arr)
    }
    ```

---
## 메모이제이션 기법
- **핵심 조건**
1. 동일한 계산의 반복: 함수가 동일한 입력 값으로 여러 번 호출될 때
2. 참조 투명성: 함수의 출력이 **오직 입력 값**에만 의존, 외부 상태(시간,전역 변수 등)에 의해 변하지 않을 때

    ### 과정
    1. 함수가 호출되면, 먼저 입력 값(인수)를 기반으로 **저장소(캐시)**에 결과가 있는지 확인
    2. 캐시 히트(결과가 있을 경우): 저장된 결과 즉시 반환(계산 생략, O(1))
    3. 캐시 미스(결과가 없을 경우): 함수를 실행하여 결과 계산
    4. 결과를 반환하기 전에 해당 입력 값과 결과 값 캐시에 저장
    ```python
    # python
    # 피보나치 수열(메모이제이션 ❌)
    def fibo(n):
        # 1. 종료조건
        if n <= 1:
            return n # 0, 1은 값이 그대로 나옴

        else:
            return fibo(n - 2) + fibo(n - 1)
    # fibo(5)
    # fibo(3) + fibo(4)
    # fibo(1) + fibo(2) + fibo(2) + fibo(3)
    # 1 + fibo(0) + fibo(1) + fibo(0) + fibo(1) + fibo(1) + fibo(2)
    # 1 + 0 + 1 + 0 + 1 + 1 + fibo(1) + fibo(0)
    # 1 + 0 + 1 + 0 + 1 + 1 + 1 + 0
    # 5

    # 피보나치 수열(메모이제이션 ⭕)
    memo = [0] * (n + 1)
    memo[0] = 0
    memo[1] = 1
    
    def fibo(n):
        if memo[n] != 0: 
            return memo[n]
        memo[n] = fibo(n - 1) + fibo(n - 2)
        return memo[n]
    # fibo(5)
    # memo[5] = fibo(4) + fibo(3)
    # memo[5] = fibo(3) + fibo(2) + fibo(2) + fibo(1) -> fibo(2)까지 바로 계산되고 그럼 바로 3, 4 가능
    ```
    ```C++
    // C++
    #include <iostream>
    #include <vector>

    using namespace std;

    // 피보나치 수열 (메모이제이션 ❌)
    int fibo(int n)
    {
        if (n < 2)
            return n;
        
        return fibo(n - 1) + fibo(n - 2);
    }

    // 피보나치 수열 (메모이제이션 ⭕)
    vector<int> memo(5, 0); // memo 배열을 5 크기로 0 초기화
    memo[0] = 0;
    memo[1] = 1;

    int fibo(vector<int>& memo, n)
    {
        if (memo[n] != 0)
            return memo[n];
        
        memo[n] = fibo(n - 1) + memo(n - 2);
        return memo[n];
    }
    ``