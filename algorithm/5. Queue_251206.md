## Queue란?
- 먼저 들어온 데이터가 먼저 나가는 선형구조 ➡ First In First Out(FIFO)
- Front: 저장된 원소 중 첫번째 원소이자 삭세된 위치
- Rear: 저장된 원소 중 마지막 원소

    ### 기본 연산
    - ```from collections import deque ```

    |연산|기능|
    |:---|:---|
    |```deque()```|공백 상태의 큐 생성|
    |```queue.append()```|**rear 다음**에 원소를 **삽입**|
    |```queue.popleft()```|front에서 원소를 **삭제**하고 **반환**|
    |```is_empty()```|공백 상태인지 확인|
    |```is_full()```|포화 상태 확인|
    |```qpeek()```|front에서 원소 반환(삭제❌)|
    🚨 is_full(): 배열 기반으로 큐를 생성할 때 필요한 내가 선언하는 함수, deque()의 경우 메모리 제한 도달 전에 자동으로 크기를 늘리므로 필요 없음

---

## 큐 종류
### 1. 선형 큐 (Linear Queue)
- 데이터를 일렬로 저장, 앞에서 꺼내고 뒤에서 넣는 기본 큐 구조

    |상태|의미|
    |:---|:---|
    |```front == rear == -1```|초기 상태|
    |```front == rear```|공백 상태|
    |```rear == n - 1```|포화상태|

    ```python
    # python
    from collections import deque

    queue = deque()

    for i in range(1, 4): # 세 개의 데이터 1,2,3을 차례로 삽입
        queue.append(i)
    
    for _ in range(3): # 큐에서 세 개의 데이터 차례로 출력
        print(queue.popleft())
    ```
    ```C++
    #include <iostream>
    #include <deque>

    using namespace std;

    int main ()
    {
        deque<int> queue;

        for (int i = 1; i < 4; i++)
        {
            queue.push_back(i);
        }

        for (int i = 0; i < 3; i++)
        {
            cout<< queue.front() << endl; // front 값 출력만
            queue.pop_front(); // 실제로 front 값 삭제
        }

        return 0;
    }
    ```

### 2. 원형 큐 (Circular Queue)
- 선형 큐의 문제점: 배열의 앞 부분에 활용할 수 있는 공간이 있음에도 포화상태로 인식
- 선형 큐의 공간 낭비를 막기 위해 처음과 끝이 연결된 구조

    |상태|의미|
    |:---|:---|
    |```front == rear == (n-1)```|front와 rear의 위치가 배열의 마지막 인덱스에 도착|
    |```front == (rear + 1) % n```|포화 상태|

    ```python
    # python
    # dequeue 없이 구현하기
    
    n = 4
    queue = [0] * n
    front = rear = 0

    # 값 추가하기
    for i in range(1, n + 1):
        if front == (rear + 1) % n: # 포화상태
            break

        else:
            rear += 1
            queue[rear % n] = i

    # 값 삭제하기
    for _ in range(n):
        if front == rear: # 공백상태
            break

        else:
            front += 1
            queue[front % n] =  0
    ```
    ```C++
    // C++
    #include <iostream>
    #include <vector>

    using namespace std;

    int main ()
    {
        vector<int> queue(4, 0);
        int front = 0
        int rear = 0

        for (int i = 1, i < 4; i++)
        {
            if (front == (rear + 1) % 4) break;

            else
            {
                queue.push_back(i % 4);
                rear += 1;   
            }
        }

        for (int i = 0; i < 4; i++)
        {
            if (rear == (front + 1) % 4) break;

            else
            {
                cout << queue[front] << endl;
                queue[front] = 0;
                front += 1
            }
        }
    }
    ```
### 3. 연결 큐 (Linked Queue)
- 연결 리스트를 이용해 구현한 큐, 크기를 필요한 만큼 늘리고 줄이는게 가능
### 4. 우선순위 큐 (Priority Queue)
- 우선순위를 가진 항목들을 저장하는 큐
- FIFO 순서가 아니라 우선순위가 높은 순서대로 먼저 출력
- 적용분야: 시뮬레이션 시스템, 네트워크 트래픽 제어, 운영체제의 테스크 스케쥴링

## 참고

### 1. 🆚 `std::deque` vs. `std::queue` 비교

| 특징 | `std::deque` (Double-Ended Queue) | `std::queue` (Queue Adapter) |
| :--- | :--- | :--- |
| **분류** | **컨테이너** (자료를 직접 저장하는 구조) | **컨테이너 어댑터** (기존 컨테이너의 인터페이스를 변경) |
| **구현 기반** | 동적 배열을 블록 형태로 연결하여 구현 | 기본적으로 **`std::deque`**를 내부 컨테이너로 사용 |
| **접근 방식** | **양방향** 접근 (앞/뒤 모두 삽입/삭제 가능) | **단방향** 접근 (FIFO 규칙만 강제) |
| **주요 메서드** | `push_front()`, `pop_front()`, `push_back()`, `pop_back()` | `push()`, `pop()`, `front()`, `back()` |
| **임의 접근** | **가능** (`[i]`) | **불가능** (오직 `front()`와 `back()`만 접근 가능) |
| **목적** | **양쪽 끝에서의 $O(1)$ 빠른 삽입/삭제**가 필요할 때 | **FIFO(선입선출) 규칙**을 엄격하게 적용하고 싶을 때 |

### 2.  Python `collections.deque` 주요 함수 (O(1) 연산)

| 연산 유형 | 메서드 | 기능 | 큐/스택 역할 |
| :--- | :--- | :--- | :--- |
| **삽입 (Enqueue/Push)** | `append(item)` | 데이터를 **오른쪽 끝(Rear)**에 추가합니다. | 큐(Enqueue) |
| | `appendleft(item)` | 데이터를 **왼쪽 끝(Front)**에 추가합니다. | 큐/덱(Push Front) |
| **삭제 (Dequeue/Pop)** | `popleft()` | 데이터를 **왼쪽 끝(Front)**에서 삭제하고 반환합니다. | 큐(Dequeue) |
| | `pop()` | 데이터를 **오른쪽 끝(Rear)**에서 삭제하고 반환합니다. | 스택(Pop) |
| **조회 (Peek)** | `[0]` | **가장 앞(Front)**의 데이터를 삭제 없이 조회합니다. | 큐/덱 (Peek Front) |
| | `[-1]` | **가장 뒤(Rear)**의 데이터를 삭제 없이 조회합니다. | 스택/덱 (Peek Rear) |
| **초기화** | `deque()` | 빈 `deque` 객체를 생성합니다. | 큐/스택 생성 |
| **크기** | `len(deque)` | 현재 `deque`에 담긴 요소의 개수를 반환합니다. | Size 확인 |
| **확인** | `not deque` | 큐가 비어있는지 확인합니다. (`len() == 0`과 동일) | is_empty() |
| **확장** | `extend(iterable)` | iterable의 요소를 **오른쪽 끝**에 추가합니다. | 대량 삽입 |
| | `extendleft(iterable)` | iterable의 요소를 **왼쪽 끝**에 추가합니다. | 대량 삽입 |