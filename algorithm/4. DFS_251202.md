## DFS(Depth First Search)
- **한 방향으로 가능한 한 깊게 탐색**한 후, 더 이상 갈 곳이 없으면 되돌아와 다른 방향을 탐색
- 비선형 자료구조를 탐색하는 방법, 모든 자료를 빠짐없이 검색

    ### 동작 원리
    1. 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색
    2. 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 복귀
    3. 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점 방문
    ✳ 2 - 3번의 동작 때문에 후입선출 구조의 **스택 사용**

    ### 그래프 정의 방법
    DFS(또는 BFS 구현 전)그래프의 노드와 간선 관계를 표현하기 위해 그래프 구조 저장 필요
    ||인접 행렬|인접 리스트|
    |:---|:---|:---|
    |구조|node_num * node_num 크기의 2차원 배열|node_num 크기의 배열|
    |저장 방식|행렬 A에서 A[i][j] 값을 통해 노드 i와 j 사이의 간선 유무 확인|노드 i의 배열 인덱스에는 i와 연결된 모든 노드 j, k,..의 **목록(리스트)** 이 저장|
    |장점|간선이 존재하는 즉시 확인 가능(O(1)), 구현 간단|메모리 효율 높음, 노드 순회 빠름|
    |단점|메모리 낭비 심함, 노드 개수 많아지면 메모리 사용량 급격히 증가|두 노드 사이에 간선이 존재하는지 확인하려면 해당 노드의 리스트를 순회해야하므로 시간 소모 높음|
    ```python
    # python 
    # 인접 행렬
    node_num = 5
    line_num = 5 # 간선 수

    # 각 노드 간의 간선 유무를 표시할 행렬
    # 0 = 간선 ❌, 1 = 간선 ⭕
    adj_matrix = [[0] * node_num for i in range(node_num)]

    # 입력이 start_node end_node로 들어온다고 가정
    # 단방향 간선이라고 가정
    # (양방향이면 그냥 start, end 바꿔서 저장 한번 더)
    for i in range(line_num):
        start, end = map(int, input().split())
        adj_matrix[start][end] = 1
    
    # 인접 리스트
    adj_list = [[] for _ in range(num_num)] 

    for i in range(line_num):
        start, end = map(int, input().split())
        adj_list[start].append(end)
    ```
    ```C++
    // C++
    #include <iostream>
    #include <vector>

    using namespace std;

    #define NODE_NUM 5
    #define LINE_NUM 5

    int main()
    {
        // 인접 행렬
        vector<vector<int>> adj_matrix(NODE_NUM, vector<int>(NODE_NUM, 0));

        // 인접 리스트
        vector<vector<int>> adj_list(NODE_NUM);

        int start_node, end_node;

        for (int i = 0; i < LINE_NUM; i++)
        {
            cin >> start_node >> end_node;

            adj_matrix[start_node][end_node] = 1;

            adj_list[start_node].push_back(end_node);
        }
    }
    ```

    ### 기본구조
    ```python
    # python
    def DFS(start_node, node_num, adj_list):
        # 초기화
        stack = []
        visited = [0] * (node_num + 1)

        # 첫 노드 저장
        stack.append(start_node)
        visited[start_node] = 1

        while stack:
            now_node = stack.pop()

            for adj_node in adj_list[now_node]:
                if not visited[adj_node]:
                    stack.append(adj_node)
                    visited[adj_node] = 1
    ```
    ```C++
    // C++
    #include <iostream>
    #include <vector>
    #include <stack>

    using namespace std;

    void DFS(int start_node, int node_num, const vector<vector<int>>& adj_list)
    {
        // 초기화
        stack<int> s;
        vector<int> visited(node_num, 0);

        // start_node 저장
        s.push(start_node);
        visited[start_node] = 1;

        while (!s.empty())
        {
            int now_node = s.top(); // s.top()은 값만 줌
            s.pop(); // s.pop()은 요소 제거만함 반환 안함

            for (int adj_node:adj_list[now_node])
            {
                if (visited[adj_node] == 0)
                {
                    s.push(adj_node);
                    visited[adj_node] = 1;
                }
            }
        }
    }
    ```