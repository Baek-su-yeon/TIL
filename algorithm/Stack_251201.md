## Stack이란
- 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 선형 자료구조
- Last-In-First-Out(LIFO), 마지막에 들어온게 제일 빨리 나감(후입선출)
    ### 기본 연산
    ```python
    # python
    # push 연산
    # 1. 메소드 활용
    def my_push(item):
        stack.append(item)

    def my_pop(item):
        if len(stack) == 0:
            return print("underflow")
        else:
            return stack.pop()
    
    # 2. 인덱스 활용
    def my_push(item, size):
        global top
        top += 1
        if top == size:
            print("overflow")
        else:
            stack[top] = item

    def my_pop(item, size):
        global top
        if top == -1:
            return print("underflow")
        else:
            top -= 1 # top 인덱스 고쳐야하니깐 먼저
            return stack[top + 1]
    ```
    ```C++
    #include <iostream>
    #include <stack>

    using namespace std;

    // 1. std::stack 사용
    void my_push()
    {
        stack<int> s; // 정수형 스택 선언
        s.push(10);
    }

    void my_pop(stack<int>& s)
    {
        s.pop();
    }

    // 2. 인덱스 사용
    const int MAX_SIZE = 5;
    int stack_arr[MAX_SIZE];
    int top = -1 // 빈 스텍 -1부터 시작

    void my_push(int item)
    {
        if (top >= MAX_SIZE - 1)
        {
            cout << "Overflow" << endl;
            return;
        }
        stack_arr[++top] = item; // top 증가 후 삽입
    }

    void my_pop()
    {
        if (top == -1)
        {
            cout <<"Underflow" << endl;
            return -1;
        }
        return stack_arr[top--]; // 현재 top요소 반환 후 감소
    }
    ```
    ### Stack 응용: 괄호검사
    **조건**
    1. 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야한다.
    2. 같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다.
    3. 괄호 사이에는 포함 관계만 존재한다.
    **과정**
    1. 문자열에 있는 괄호를 차례대로 검사하면서 왼쪽 괄호를 만나면 삽입
    2. 오른쪽 괄호를 만나면 스택에서 top 괄호를 삭제하고 짝이 맞는지 검사
    ```python
    #python
    def parentheses(arr):
        stack = []
        for ph in arr:
            if ph == '(':
                stack.append(ph)
            elif ph == '(':
                if not stack:
                    return false
                else:
                    stack.pop()
        
        if not stack:
            return true
        
        return false
    ```
    ```C++
    // C++
    #include <iostream>
    #include <stack> // 스택 자료구조
    #include <string> // 문자열 자료형

    using namespace std;

    bool parentheses(const string& arr)
    {
        stack<char> s;

        for (char ph:arr)
        {
            if (ph == '(') s.push(ph);
            else if (ph == ')')
            {
                if (s.empty()) return false;
                else s.pop();
            }
        }

        if (s.empty()) return true;
        else return false;
    }
    ```

---
## 참고
### C++: string과 vector의 차이점
| 특징 | `std::string` | `std::vector<char>` |
| :--- | :--- | :--- |
| **주요 목적** | **텍스트(문자열)**를 저장하고 다루는 데 특화. | **일반 요소(`char`)의 동적 배열**로 사용. |
| **추상화 레벨** | **문자열(String)**이라는 고수준 추상화. | **컨테이너(Container)**라는 일반적인 개념. |
| **종료 문자** | 문자열 끝에 **널 문자(`\0`)**를 **자동으로** 포함하여 C 스타일 문자열(`char*`)과의 호환성 보장. | 널 문자를 **자동으로 추가하지 않음**. |
| **주요 연산** | `+` (문자열 연결), `find`, `substr` 등 **텍스트 기반 연산**이 풍부함. | `push_back`, `pop_back`, `insert` 등 **배열/요소 관리 연산**이 중심. |
| **특화 기능** | `std::string`에 특화된 다양한 문자열 처리 알고리즘 제공. | `char` 타입 외에 다른 타입을 저장하는 `std::vector`와 동일한 기능만 제공. |
| **일반적 사용** | 파일 내용, 사용자 입력, **모든 텍스트 데이터** 처리. | 파일의 바이트 데이터, 임시 버퍼, **문자 배열을 의도**할 때 사용. |
| **예시** | `std::string name = "Gemini";` | `std::vector<char> buffer = {'a', 'b', 'c'};` |

## 추상화 레벨(Abstraction Level)이란?

**추상화 레벨**은 컴퓨터 과학에서 **"사용자나 다른 시스템이 얼마나 구체적인 내부 구현 정보로부터 분리되어(숨겨져) 있느냐"**를 나타내는 개념입니다. 즉, 복잡한 세부 사항은 가리고 핵심적인 개념이나 기능만 사용자에게 노출하는 정도를 의미합니다.

---

### 1. 높은 추상화 레벨 (High Abstraction Level)

* **특징**: 내부의 복잡한 구현이나 '어떻게' 작동하는지를 거의 모두 숨기고, **개념**이나 **목적**에 초점을 맞춥니다.
* **장점**: 사용하기 **매우 편리**하고 오류 발생 가능성이 낮습니다.
* **예시**: C++의 **`std::string`**은 문자열을 '텍스트'라는 개념으로 다루게 하여, 메모리 관리나 널 문자(`\0`) 처리 같은 세부 사항을 숨깁니다.

### 2. 낮은 추상화 레벨 (Low Abstraction Level)

* **특징**: 데이터 구조의 물리적 작동 방식, 메모리 위치 등 내부 세부 사항을 **직접** 다룹니다.
* **장점**: 하드웨어나 메모리 관리에 대한 **정교한 제어**가 가능합니다.
* **예시**: C++의 **`std::vector<char>`**는 문자열이 아닌 'char 요소의 동적 배열' 자체를 다루게 하여, 요소 추가/제거 등의 **자료 구조 작동 방식**에 집중하게 만듭니다.

---

### 💡 비유: 자동차 운전

* **높은 추상화**: **운전자**가 '엑셀'을 밟으면 차가 움직입니다. (엔진 작동 방식을 몰라도 됨)
* **낮은 추상화**: **정비사**가 엔진의 피스톤, 연료 분사 장치를 직접 다룹니다. (정교한 제어를 위해 세부 구조를 알아야 함)