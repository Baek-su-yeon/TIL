## 버블 정렬
- 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
- 시간복잡도: **O(n^2)**

    ### 과정
    1. 첫번째 원소부터 인접한 원소끼리 계속 교환하며 맨 마지막 자리까지 이동
    2. 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬
    ```python
    # python
    
    # 오름차순
    def bubble_sort(num_list, list_len):
        for i in range(list_len - 1, 0, -1):
            # 한 단계 끝나면 가장 큰 원소가 마지막 자리로 정렬
            # 즉 이 for문이 끝나면 제일 뒤에는 큰 원소가 있어서 볼 필요 없으니 거꾸로 반복
            for j in range(i):
                if num_list[j] > num_list[j + 1]:
                    num_list[j], num_list[j + 1] = num_list[j + 1], num_list[j]

    # 내림차순
    def bubble_sort_reverse(num_list, list_len):
        for i in range(list_len - 1, 0, -1):
            for j in range(i):
                if num_list[j] < num_list[j + 1]:
                    num_list[j], num_list[j + 1] = num_list[j + 1], num_list[j]
    ```
    ```C++
    #include <vector>
    #include <algorithm> // swap 함수를 사용하기 위해 포함

    /**
     * @brief 버블 정렬을 사용하여 벡터를 오름차순으로 정렬합니다.
     * * @param arr 정렬할 정수형 벡터
     */
    void bubbleSort(std::vector<int>& arr) {
        int n = arr.size();
        // 바깥쪽 루프: 패스(Pass)의 횟수를 결정하며, n-1번 반복합니다.
        // i는 이미 정렬이 완료된 배열의 끝 부분을 나타내므로, 범위에서 제외합니다.
        for (int i = 0; i < n - 1; ++i) {
            // 안쪽 루프: 인접한 원소들을 비교하고 교환합니다.
            // 정렬되지 않은 부분(n - 1 - i)까지만 비교합니다.
            for (int j = 0; j < n - 1 - i; ++j) {
                // 오름차순: 왼쪽 원소가 오른쪽 원소보다 크면 자리를 바꿉니다.
                if (arr[j] > arr[j + 1]) {
                    std::swap(arr[j], arr[j + 1]);
                }
            }
        }
    }
    ```
---
## 카운팅 정렬
- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업
- 시간복잡도: O(n + k), n = 리스트 길이, k = 정수의 최댓값
- 제한 사항 1. 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
- 제한 사항 2. 카운트들을 위한 충분한 공간을 할당하려면 집합 내 가장 큰 정수를 알아야 가능

    ### 과정
    1. DATA에서 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열에 저장
    2. 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 카운트 원소 조정
    3. DATA의 마지막 원소부터 왼쪽으로 이동, 카운트[1]부터 n까지 이동 시 감소, TEMP에 원소 삽입
    ```python
    # python
    def counting_sort(data, temp, k):
        # data는 정렬할 배열, temp는 정렬 완료 후 배열
        count = [0] * (k + 1)

        # 1. DATA에서 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열에 저장
        for i in data:
            count[data] += 1

        # 2. 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 카운트 원소 조정
        for i in range(1, k + 1):
            count[i] += count[i-1]
        
        # 3. DATA의 마지막 원소부터 왼쪽으로 이동, 카운트[1]부터 n까지 이동 시 감소, TEMP에 원소 삽입
        for i in range(len(data) - 1, -1, -1):
    ```
    ```C++
    ```