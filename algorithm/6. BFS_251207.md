## BFS (Breadth First Search)란?
- 탐색 시작점의 인접한 정점들을 모두 차례로 방문한 후에 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방법
- Queue를 사용하며, 아무리 복잡한 구조여도 최소한의 거리로 갈 수 있는 방법 출력 가능 (시작점이 1개 이상이어도 가능)
    ```python
    # python
    from collections import deque

    def BFS(adj_arr, start, node_num):
        queue = deque()
        visited = [0] * (node_num + 1)

        # 시작점 처리
        queue.append(start)
        visited[start] = 1

        while queue:
            now = queue.popleft() # front에서 하나 빼기

            for node in adj_arr[now]: # 인접 리스트로 가정
                if not visited[node]:
                    queue.append(node)
                    visited[node] = 1
                    #visited[node] = visited[now] + 1 # 거리를 알고싶다면
    ```
    ```C++
    #include <iostream>
    #include <deque>
    #include <vector>

    using namespace std;

    #define NODE_NUM n
    
    void BFS(<vector<vector<int>>& adj_arr, int start)
    {
        deque<int> queue;
        vector<int> visited(NODE_NUM + 1, 0);

        queue.push_back(start);
        visited[start] = 1;

        while(!queue.empty())
        {
            now = queue.front(); // 앞에 값만 반환 (제거 X)
            queue.pop_front(); // 제거!

            for (int node:adj_arr[now])
            {
                if (visited[node] == 0)
                {
                    queue.push_back(node);
                    visited[node] = 1;
                    // visited[node] = visited[now] + 1
                }
            }
        }
    }
    ```